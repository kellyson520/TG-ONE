{% extends "base.html" %}
{% block title %}转发拓扑图 - Forwarder Pro{% endblock %}
{% block content %}

<div class="row g-4 h-100">
    <!-- 左侧工具栏 -->
    <div class="col-xl-3 col-lg-4">
        <div class="d-flex flex-column gap-4 sticky-top" style="top: 1.5rem; z-index: 10;">
            <!-- 操作面板 -->
            <div class="glass-card p-4">
                <h6 class="fw-bold mb-3"><i class="bi bi-tools me-2"></i>控制中心</h6>
                <div class="row g-2">
                    <div class="col-6">
                        <button class="btn btn-sm btn-outline-primary w-100 py-2" onclick="addChatNode()">
                            <i class="bi bi-chat-square d-block mb-1"></i> 聊天
                        </button>
                    </div>
                    <div class="col-6">
                        <button class="btn btn-sm btn-outline-success w-100 py-2" onclick="addRuleNode()">
                            <i class="bi bi-gear d-block mb-1"></i> 规则
                        </button>
                    </div>
                    <div class="col-6">
                        <button class="btn btn-sm btn-outline-info w-100 py-2" onclick="autoLayout()">
                            <i class="bi bi-diagram-2 d-block mb-1"></i> 布局
                        </button>
                    </div>
                    <div class="col-6">
                        <button class="btn btn-sm btn-outline-warning w-100 py-2" onclick="clearCanvas()">
                            <i class="bi bi-trash d-block mb-1"></i> 清空
                        </button>
                    </div>
                </div>

                <div class="mt-4 pt-3 border-top">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <small class="text-muted fw-bold text-uppercase">图例说明</small>
                    </div>
                    <div class="d-flex flex-column gap-2">
                        <div class="d-flex align-items-center gap-2 small">
                            <span class="badge-soft badge-soft-primary px-2">●</span> 聊天节点
                        </div>
                        <div class="d-flex align-items-center gap-2 small">
                            <span class="badge-soft badge-soft-success px-2">●</span> 转发规则
                        </div>
                        <div class="d-flex align-items-center gap-2 small">
                            <i class="bi bi-arrow-right text-primary"></i> 消息流向
                        </div>
                    </div>
                </div>
            </div>

            <!-- 统计指标 -->
            <div class="glass-card p-4">
                <div class="row text-center g-0">
                    <div class="col-6 border-end">
                        <div class="fs-4 fw-bold text-primary" id="nodeCount">0</div>
                        <div class="extra-small text-muted text-uppercase">节点数</div>
                    </div>
                    <div class="col-6">
                        <div class="fs-4 fw-bold text-success" id="connectionCount">0</div>
                        <div class="extra-small text-muted text-uppercase">拓扑连线</div>
                    </div>
                </div>
            </div>

            <!-- 属性面板 -->
            <div id="nodePropertiesPanel" class="glass-card p-4" style="display: none;">
                <h6 class="fw-bold mb-3"><i class="bi bi-sliders me-2"></i>节点属性</h6>
                <div id="nodePropertiesContent" class="small">
                    <!-- 动态渲染 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 右侧拓扑画布 -->
    <div class="col-xl-9 col-lg-8">
        <div class="glass-card h-100 overflow-hidden" style="min-height: 700px; position: relative;">
            <div class="p-3 border-bottom d-flex justify-content-between align-items-center bg-white bg-opacity-10"
                style="z-index: 5; position: relative;">
                <h6 class="fw-bold mb-0">转发拓扑图 <span class="badge badge-soft-primary ms-2">BETA</span></h6>
                <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-light" onclick="zoomIn()" title="放大"><i
                            class="bi bi-plus-lg"></i></button>
                    <button class="btn btn-outline-light" onclick="zoomOut()" title="缩小"><i
                            class="bi bi-dash-lg"></i></button>
                    <button class="btn btn-outline-light" onclick="resetZoom()" title="重置"><i
                            class="bi bi-aspect-ratio"></i></button>
                </div>
            </div>

            <div id="visualization-container" class="visualization-container-modern">
                <div id="canvas-inner" class="canvas-inner"></div>

                <!-- 浮动操作栏 -->
                <div class="floating-toolbar">
                    <div
                        class="btn-group-vertical btn-group-sm rounded-pill shadow-lg bg-white bg-opacity-10 overflow-hidden">
                        <button class="btn btn-dark border-0" onclick="toggleConnectionMode()" id="connectionModeBtn"
                            title="连接模式">
                            <i class="bi bi-node-plus"></i>
                        </button>
                        <button class="btn btn-dark border-0" onclick="selectAllNodes()" title="全选">
                            <i class="bi bi-check-all"></i>
                        </button>
                        <button class="btn btn-dark border-0" onclick="deleteSelected()" title="删除">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>

                <!-- 迷你地图 -->
                <div class="minimap-modern shadow-sm" id="minimap">
                    <canvas id="minimapCanvas" width="180" height="120"></canvas>
                    <div class="text-center extra-small text-muted mt-1">全局视图</div>
                </div>

                <!-- 加载遮罩 -->
                <div id="loadingIndicator" class="loading-overlay">
                    <div class="spinner-grow text-primary mb-3"></div>
                    <div class="fw-bold small text-muted">正在检索拓扑数据...</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 浮动输入窗口 -->
<div class="chat-input-modal" id="chatInputArea" style="display: none;">
    <div class="glass-card p-4 shadow-2xl">
        <h6 class="fw-bold mb-3">添加聊天节点</h6>
        <div class="input-group mb-3">
            <span class="input-group-text bg-transparent border-end-0"><i class="bi bi-chat-dots"></i></span>
            <input type="text" class="form-control border-start-0" id="chatLinkInput" placeholder="@username 或 ID">
        </div>
        <div class="d-flex justify-content-end gap-2">
            <button class="btn btn-sm btn-link text-muted" onclick="hideChatInput()">取消</button>
            <button class="btn btn-sm btn-primary-gradient px-4" onclick="addChatFromInput()">确认添加</button>
        </div>
    </div>
</div>
<style>
    .visualization-container-modern {
        background-color: rgba(var(--primary-rgb), 0.02);
        background-image:
            radial-gradient(circle at 2px 2px, rgba(var(--primary-rgb), 0.05) 1px, transparent 0);
        background-size: 32px 32px;
        height: 700px;
        position: relative;
        overflow: hidden;
    }

    .canvas-inner {
        width: 3000px;
        height: 3000px;
        transform-origin: 0 0;
        cursor: grab;
    }

    .node {
        position: absolute;
        min-width: 140px;
        background: white;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        z-index: 10;
        cursor: grab;
        transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
    }

    .node:hover {
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        border-color: var(--primary);
    }

    .node.selected {
        border: 2px solid var(--primary);
        box-shadow: 0 0 0 4px rgba(var(--primary-rgb), 0.1);
    }

    .node.chat {
        border-top: 4px solid var(--primary);
    }

    .node.rule {
        border-top: 4px solid var(--success);
    }

    .node.disabled {
        opacity: 0.6;
        filter: grayscale(0.8);
    }

    .floating-toolbar {
        position: absolute;
        right: 1.5rem;
        top: 1.5rem;
        z-index: 20;
    }

    .minimap-modern {
        position: absolute;
        bottom: 1.5rem;
        right: 1.5rem;
        background: rgba(255, 255, 255, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.5rem;
        z-index: 20;
    }

    .loading-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
    }

    .chat-input-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(4px);
    }

    .connection-line {
        position: absolute;
        height: 2px;
        background: var(--primary);
        transform-origin: 0 50%;
        pointer-events: none;
        z-index: 5;
        opacity: 0.4;
    }

    .connection-arrow {
        position: absolute;
        width: 10px;
        height: 10px;
        border-top: 2px solid var(--primary);
        border-right: 2px solid var(--primary);
        transform-origin: 50% 50%;
        z-index: 5;
        opacity: 0.4;
    }
</style>

<script>
    class VisualizationCanvas {
        constructor() {
            this.container = document.getElementById('visualization-container');
            this.inner = document.getElementById('canvas-inner');
            this.nodes = new Map();
            this.connections = [];
            this.selectedNodes = new Set();
            this.isDragging = false;
            this.isPanning = false;
            this.draggedNode = null;
            this.dragOffset = { x: 0, y: 0 };
            this.panOffset = { x: 0, y: 0 };
            this.connectionMode = false;
            this.connectingFrom = null;
            this.scale = 1;

            this.initializeEventListeners();
            this.loadExistingData();
        }

        initializeEventListeners() {
            this.inner.addEventListener('mousedown', this.onMouseDown.bind(this));
            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            this.container.addEventListener('wheel', this.onWheel.bind(this), { passive: false });

            // 右键菜单预防
            this.container.addEventListener('contextmenu', e => e.preventDefault());
        }

        async loadExistingData() {
            try {
                const indicator = document.getElementById('loadingIndicator');
                if (indicator) indicator.style.display = 'flex';

                const res = await apiManager.getVisualizationGraph();
                if (res.success) {
                    this.renderGraph(res.data);
                } else {
                    notificationManager.error(res.error || '拓扑集成失败');
                }
            } catch (e) {
                console.error(e);
                notificationManager.error('拓扑计算引擎响应异常');
            } finally {
                const indicator = document.getElementById('loadingIndicator');
                if (indicator) indicator.style.display = 'none';
            }
        }

        renderGraph(graphData) {
            this.clearCanvas(false);
            const { nodes, edges } = graphData;

            // 改进：功能分层布局 (Sources -> Rules -> Targets)
            const ruleIds = new Set(nodes.filter(n => n.type === 'rule').map(n => n.id));
            const sourceIds = new Set();
            const targetIds = new Set();

            edges.forEach(e => {
                if (ruleIds.has(e.target)) sourceIds.add(e.source);
                if (ruleIds.has(e.source)) targetIds.add(e.target);
            });

            const counts = { source: 0, rule: 0, target: 0, other: 0 };
            const xMap = { source: 80, rule: 450, target: 820, other: 450 };

            nodes.forEach((n) => {
                const node = this.createNode(n.type, n.label, n.data, n.id);
                this.nodes.set(n.id, node);

                let tier = 'other';
                if (n.type === 'rule') tier = 'rule';
                else if (sourceIds.has(n.id) && !targetIds.has(n.id)) tier = 'source';
                else if (targetIds.has(n.id)) tier = 'target';
                else tier = 'source'; // 默认左侧

                const x = xMap[tier];
                const y = 100 + (counts[tier]++ * 160);

                this.positionNode(node, x, y);
            });

            edges.forEach(e => {
                const from = this.nodes.get(e.source);
                const to = this.nodes.get(e.target);
                if (from && to) this.createConnection(from, to, e.type);
            });

            this.updateStats();
            this.updateMinimap();
        }

        createNode(type, label, data = {}, id = null) {
            const node = document.createElement('div');
            node.id = id || `node_${Date.now()}`;
            node.className = `node ${type} animate-fade-in`;
            node.innerHTML = `
                <div class="fw-bold mb-1 small d-flex justify-content-between align-items-center">
                    <span><i class="bi bi-${type === 'chat' ? 'chat-dots' : 'gear'} me-1"></i>${label}</span>
                    <i class="bi bi-grip-vertical opacity-25"></i>
                </div>
                <div class="extra-small text-muted text-truncate" style="max-width: 120px;">
                    ${type === 'chat' ? (data.telegram_chat_id || 'ID未知') : (data.enabled ? '运行中' : '已禁用')}
                </div>
                ${type === 'rule' ? `
                    <div class="mt-2 d-flex gap-1">
                        <span class="badge badge-soft-info extra-small">${data.keywords_count || 0} 词</span>
                        <span class="badge badge-soft-warning extra-small">${data.replace_rules_count || 0} 改</span>
                    </div>
                ` : ''}
            `;
            this.inner.appendChild(node);
            node.nodeData = { type, label, data, id: node.id };

            // 绑定点击事件，处理连接模式
            node.addEventListener('click', (e) => {
                e.stopPropagation();
                if (this.connectionMode) {
                    this.handleConnectionModeClick(node);
                } else {
                    this.toggleNodeSelection(node, e.ctrlKey || e.metaKey);
                }
            });

            return node;
        }

        positionNode(node, x, y) {
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            this.updateAllConnections();
        }

        createConnection(from, to, type = 'default') {
            const conn = {
                from,
                to,
                type,
                line: document.createElement('div'),
                arrow: document.createElement('div')
            };
            conn.line.className = `connection-line ${type}`;
            conn.arrow.className = `connection-arrow ${type}`;
            this.inner.appendChild(conn.line);
            this.inner.appendChild(conn.arrow);
            this.connections.push(conn);
            this.updateConnection(conn);
            return conn;
        }

        updateConnection(conn) {
            const fX = conn.from.offsetLeft + conn.from.offsetWidth;
            const fY = conn.from.offsetTop + (conn.from.offsetHeight / 2);
            const tX = conn.to.offsetLeft;
            const tY = conn.to.offsetTop + (conn.to.offsetHeight / 2);

            const dist = Math.sqrt((tX - fX) ** 2 + (tY - fY) ** 2);
            const angle = Math.atan2(tY - fY, tX - fX) * 180 / Math.PI;

            conn.line.style.left = `${fX}px`;
            conn.line.style.top = `${fY}px`;
            conn.line.style.width = `${dist}px`;
            conn.line.style.transform = `rotate(${angle}deg)`;

            conn.arrow.style.left = `${tX - 10}px`;
            conn.arrow.style.top = `${tY - 5}px`;
            conn.arrow.style.transform = `rotate(${angle + 45}deg)`;
        }

        updateAllConnections() {
            this.connections.forEach(c => this.updateConnection(c));
        }

        onMouseDown(e) {
            const node = e.target.closest('.node');
            if (node) {
                if (e.button === 0) { // 左键
                    this.isDragging = true;
                    this.draggedNode = node;
                    this.dragOffset.x = (e.clientX / this.scale) - node.offsetLeft;
                    this.dragOffset.y = (e.clientY / this.scale) - node.offsetTop;
                    if (!this.selectedNodes.has(node)) {
                        this.toggleNodeSelection(node, false);
                    }
                }
            } else {
                // 背景拖拽 (Pan)
                this.isPanning = true;
                this.panOffset.x = e.clientX - this.inner.offsetLeft;
                this.panOffset.y = e.clientY - this.inner.offsetTop;
                this.inner.style.cursor = 'grabbing';
            }
        }

        onMouseMove(e) {
            if (this.isDragging && this.draggedNode) {
                const x = (e.clientX / this.scale) - this.dragOffset.x;
                const y = (e.clientY / this.scale) - this.dragOffset.y;
                this.positionNode(this.draggedNode, x, y);
                this.updateMinimap();
            } else if (this.isPanning) {
                const x = e.clientX - this.panOffset.x;
                const y = e.clientY - this.panOffset.y;
                this.inner.style.left = `${x}px`;
                this.inner.style.top = `${y}px`;
            }
        }

        onMouseUp() {
            this.isDragging = false;
            this.isPanning = false;
            this.draggedNode = null;
            this.inner.style.cursor = 'grab';
        }

        onWheel(e) {
            e.preventDefault();
            const rect = this.container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const oldScale = this.scale;
            this.scale = e.deltaY > 0 ? Math.max(0.2, this.scale - 0.1) : Math.min(3, this.scale + 0.1);

            // TODO: 这里可以优化缩放中心点，目前先简单处理
            this.inner.style.transform = `scale(${this.scale})`;
            this.updateMinimap();
        }

        toggleNodeSelection(node, isMulti) {
            if (!isMulti) this.selectedNodes.forEach(n => n.classList.remove('selected'));
            if (!isMulti) this.selectedNodes.clear();

            if (this.selectedNodes.has(node)) {
                this.selectedNodes.delete(node);
                node.classList.remove('selected');
                if (this.selectedNodes.size === 0) {
                    document.getElementById('nodePropertiesPanel').style.display = 'none';
                }
            } else {
                this.selectedNodes.add(node);
                node.classList.add('selected');
                this.showProperties(node);
            }
        }

        showProperties(node) {
            const p = document.getElementById('nodePropertiesPanel');
            const c = document.getElementById('nodePropertiesContent');
            const { type, label, data } = node.nodeData;
            p.style.display = 'block';

            let html = `
                <div class="mb-3">
                    <label class="extra-small text-muted text-uppercase fw-bold">节点名称</label>
                    <input class="form-control form-control-sm mt-1 bg-white bg-opacity-5 text-white border-0" value="${label}">
                </div>
                <div class="mb-3">
                    <label class="extra-small text-muted text-uppercase fw-bold">类型</label>
                    <div class="mt-1"><span class="badge badge-soft-${type === 'chat' ? 'primary' : 'success'}">${type === 'chat' ? '聊天' : '规则'}</span></div>
                </div>
            `;

            if (type === 'chat') {
                html += `
                    <div class="mb-3">
                        <label class="extra-small text-muted text-uppercase fw-bold">Telegram ID</label>
                        <div class="mt-1 extra-small opacity-75">${data.telegram_chat_id || 'N/A'}</div>
                    </div>
                `;
            } else {
                html += `
                    <div class="mb-3">
                        <label class="extra-small text-muted text-uppercase fw-bold">规则状态</label>
                        <div class="mt-1 extra-small">${data.enabled ? '<span class="text-success">● 启用</span>' : '<span class="text-secondary">● 禁用</span>'}</div>
                    </div>
                `;
            }

            c.innerHTML = html;
        }

        updateStats() {
            const nodeCountEl = document.getElementById('nodeCount');
            const connectionCountEl = document.getElementById('connectionCount');
            if (nodeCountEl) nodeCountEl.textContent = this.nodes.size;
            if (connectionCountEl) connectionCountEl.textContent = this.connections.length;
        }

        updateMinimap() {
            const cvs = document.getElementById('minimapCanvas');
            if (!cvs) return;
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0, 0, 180, 120);

            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.fillRect(0, 0, 180, 120);

            this.nodes.forEach(n => {
                ctx.fillStyle = n.nodeData.type === 'chat' ? '#6366f1' : '#10b981';
                // 缩放坐标映射
                const mx = (n.offsetLeft / 3000) * 180;
                const my = (n.offsetTop / 3000) * 120;
                ctx.fillRect(mx, my, 6, 4);
            });
        }

        clearCanvas(confirmManual = true) {
            if (confirmManual && !confirm('确定要清空拓扑图吗？此操作仅在前端生效。')) return;

            this.nodes.forEach(n => n.remove());
            this.nodes.clear();
            this.connections.forEach(c => {
                c.line.remove();
                c.arrow.remove();
            });
            this.connections = [];
            this.selectedNodes.clear();
            document.getElementById('nodePropertiesPanel').style.display = 'none';
            this.updateStats();
            this.updateMinimap();
        }

        toggleConnectionMode() {
            this.connectionMode = !this.connectionMode;
            const btn = document.getElementById('connectionModeBtn');
            btn.classList.toggle('btn-primary', this.connectionMode);
            btn.classList.toggle('btn-dark', !this.connectionMode);

            if (this.connectionMode) {
                notificationManager.info('已开启连线模式：依次点击两个节点建立转发关系');
                this.container.style.cursor = 'crosshair';
            } else {
                this.container.style.cursor = 'grab';
                this.connectingFrom = null;
            }
        }

        handleConnectionModeClick(node) {
            if (!this.connectingFrom) {
                this.connectingFrom = node;
                node.classList.add('selected');
                notificationManager.info('请选择目标节点');
            } else {
                if (this.connectingFrom === node) {
                    this.connectingFrom = null;
                    node.classList.remove('selected');
                    return;
                }

                // 建立连接
                this.createConnection(this.connectingFrom, node);
                notificationManager.success('临时链路已创建');

                this.connectingFrom.classList.remove('selected');
                this.connectingFrom = null;
                this.toggleConnectionMode(); // 自动退出连线模式
            }
        }

        selectAllNodes() {
            this.nodes.forEach(n => {
                this.selectedNodes.add(n);
                n.classList.add('selected');
            });
            notificationManager.info(`已选中 ${this.nodes.size} 个节点`);
        }

        deleteSelected() {
            if (this.selectedNodes.size === 0) {
                notificationManager.warning('请先选择要删除的节点');
                return;
            }

            if (!confirm(`确定要从视图中移除选中的 ${this.selectedNodes.size} 个节点吗？`)) return;

            this.selectedNodes.forEach(node => {
                // 移除相关的连线
                this.connections = this.connections.filter(conn => {
                    if (conn.from === node || conn.to === node) {
                        conn.line.remove();
                        conn.arrow.remove();
                        return false;
                    }
                    return true;
                });

                // 移除节点
                const nodeId = node.nodeData.id;
                this.nodes.delete(nodeId);
                node.remove();
            });

            this.selectedNodes.clear();
            document.getElementById('nodePropertiesPanel').style.display = 'none';
            this.updateStats();
            this.updateMinimap();
            notificationManager.success('节点已移除');
        }
    }

    let canvas;
    document.addEventListener('DOMContentLoaded', () => {
        canvas = new VisualizationCanvas();

        // 快捷键支持
        window.addEventListener('keydown', e => {
            if (e.key === 'Delete') canvas.deleteSelected();
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                canvas.selectAllNodes();
            }
            if (e.key === 'Escape') {
                if (canvas.connectionMode) canvas.toggleConnectionMode();
                canvas.selectedNodes.forEach(n => n.classList.remove('selected'));
                canvas.selectedNodes.clear();
                document.getElementById('nodePropertiesPanel').style.display = 'none';
            }
        });
    });

    function addChatNode() { document.getElementById('chatInputArea').style.display = 'flex'; }
    function hideChatInput() { document.getElementById('chatInputArea').style.display = 'none'; }
    function addRuleNode() {
        notificationManager.info('请通过配置页创建规则，或在连线模式下动态添加。');
    }

    function addChatFromInput() {
        const val = document.getElementById('chatLinkInput').value;
        if (val) {
            const node = canvas.createNode('chat', val, { telegram_chat_id: val });
            canvas.positionNode(node, 100, 100);
            canvas.nodes.set(`new_${Date.now()}`, node);
            canvas.updateStats();
            canvas.updateMinimap();
            hideChatInput();
            notificationManager.success('聊天节点已添加');
        }
    }

    function zoomIn() { canvas.scale = Math.min(3, canvas.scale + 0.2); canvas.inner.style.transform = `scale(${canvas.scale})`; }
    function zoomOut() { canvas.scale = Math.max(0.2, canvas.scale - 0.2); canvas.inner.style.transform = `scale(${canvas.scale})`; }
    function resetZoom() {
        canvas.scale = 1;
        canvas.inner.style.transform = `scale(1)`;
        canvas.inner.style.left = '0px';
        canvas.inner.style.top = '0px';
    }
    function autoLayout() { canvas.loadExistingData(); }
    function toggleConnectionMode() { canvas.toggleConnectionMode(); }
    function selectAllNodes() { canvas.selectAllNodes(); }
    function deleteSelected() { canvas.deleteSelected(); }
    function clearCanvas() { canvas.clearCanvas(); }
</script>
{% endblock %}